/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "BaseSolanaAdapter": () => (/* reexport */ BaseSolanaAdapter)
});

;// CONCATENATED MODULE: external "@web3auth/base"
const base_namespaceObject = require("@web3auth/base");
;// CONCATENATED MODULE: external "bs58"
const external_bs58_namespaceObject = require("bs58");
var external_bs58_default = /*#__PURE__*/__webpack_require__.n(external_bs58_namespaceObject);
;// CONCATENATED MODULE: ./src/baseSolanaAdapter.ts


class BaseSolanaAdapter extends base_namespaceObject.BaseAdapter {
  async authenticateUser() {
    var _this$chainConfig;

    if (!this.provider || !((_this$chainConfig = this.chainConfig) !== null && _this$chainConfig !== void 0 && _this$chainConfig.chainId)) throw base_namespaceObject.WalletLoginError.notConnectedError();
    const {
      chainNamespace,
      chainId
    } = this.chainConfig;
    if (this.status !== base_namespaceObject.ADAPTER_STATUS.CONNECTED) throw base_namespaceObject.WalletLoginError.notConnectedError("Not connected with wallet, Please login/connect first");
    const accounts = await this.provider.request({
      method: "getAccounts"
    });

    if (accounts && accounts.length > 0) {
      const existingToken = (0,base_namespaceObject.getSavedToken)(accounts[0], this.name);

      if (existingToken) {
        const isExpired = (0,base_namespaceObject.checkIfTokenIsExpired)(existingToken);

        if (!isExpired) {
          return {
            idToken: existingToken
          };
        }
      }

      const payload = {
        domain: window.location.origin,
        uri: window.location.href,
        address: accounts[0],
        chainId: parseInt(chainId, 16),
        version: "1",
        nonce: Math.random().toString(36).slice(2),
        issuedAt: new Date().toISOString()
      };
      const challenge = await (0,base_namespaceObject.signChallenge)(payload, chainNamespace);
      const encodedMessage = new TextEncoder().encode(challenge);
      const signedMessage = await this.provider.request({
        method: "signMessage",
        params: {
          message: encodedMessage,
          display: "utf8"
        }
      });
      const idToken = await (0,base_namespaceObject.verifySignedChallenge)(chainNamespace, external_bs58_default().encode(signedMessage), challenge, this.name, this.sessionTime);
      (0,base_namespaceObject.saveToken)(accounts[0], this.name, idToken);
      return {
        idToken
      };
    }

    throw base_namespaceObject.WalletLoginError.notConnectedError("Not connected with wallet, Please login/connect first");
  }

  async disconnect() {
    if (this.status !== base_namespaceObject.ADAPTER_STATUS.CONNECTED) throw base_namespaceObject.WalletLoginError.disconnectionError("Not connected with wallet");
    const accounts = await this.provider.request({
      method: "getAccounts"
    });

    if (accounts && accounts.length > 0) {
      (0,base_namespaceObject.clearToken)(accounts[0], this.name);
    }
  }

}
;// CONCATENATED MODULE: ./src/index.ts

module.exports = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=baseSolanaAdapter.cjs.js.map